# 최단 경로 알고리즘 이해

"""
1. 최단 경로 문제란
    - 두 노드를 잇는 가장 짧은 경로를 찾는 문제
    - 가중치 그래프에서 간선의 가중치 합이 최소가 되도록 하는 경로를 찾는 것이 목적

    최단 경로 문제 종류
    1. 단일 출발 및 단일 도착 최단 경로 문제 
        - 그래프 내의 특정 노드 u에서 출발, 또다른 특정 노드 v에 도탁하는 가장 짧은 경로를 찾는 문제

    2. 단일 출발 최단 경로 문제 (다익스트라 알고리즘) 
        - 그래프 내의 노드 i와 그래프 내 다른 모든 노드 각각의 가장 짧은 경로를 찾는 문제

    3. 전체 쌍 최단 경로 
        - 그래프 내의 모든 노드 쌍(u, v)에 대한 최단 경로를 찾는 문제

2. 최단 경로 알고리즘 - 다익스트라 알고리즘 (단일 출발 최단 경로 문제)
    다익스트라 알고리즘 로직
        - 첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가며, 최단 거리를 갱신하는 기법
        - 너비우선탐색(BFS)와 유사
            - 첫 정점부터 각 노드간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인접 노드 간의 거리부터 먼저 계산하면서, 첫 정점부터 해당 노드간의 가장 짧은 거리를 해당 배열에 업데이트
                * 다양한 변형 로직이 있지만 가장 개선된 우선순위 큐를 사용하는 방식에 집중

    우선순위 큐를 이용한 다익스트라 알고리즘
        우선순위 큐는 MinHeap 방식을 활용해서, 현재 가장 짧은 거리를 가진 노드 정보를 먼저 꺼내게 됨

        1) 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장
            - 초기에는 첫 정점의 거리는 0, 나머지는 무한대로 저장 (inf라고 표현)
            - 우선순위 큐에 첫 (정점, 거리0)만 먼저 넣음

        2) 우선순위 큐에서 노드를 꺼냄
            - 처음에는 첫 정점만 저장되어 있으므로, 첫 정점이 꺼내짐
            - 첫 정점에 인접한 노드들 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교한다
            - 배열에 저장되어 있는 거리보다, 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우, 배열에 해당 노드의 거리를 업데이트한다.
            - 배열에 해당 노드의 거리가 업데이트된 경우, 우선순위 큐에 넣는다.
                - 결과적으로 너비 우선 탐색 방식과 유사하게, 첫 정점에 인접한 노드들을 순차적으로 방문하게 됨
                - 만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리(루트)를 가진 (노드, 거리)의 경우에는 해당 노드와 인접한 노드간의 거리 계산을 하지 않음

        3) 2번의 과정을 우선순위 큐에 꺼낼 노드가 없을 때까지 반복한다.

3. 예제로 이해하는 다익스트라 알고리즘 (우선순위 큐 활용)

    1단계. 초기화 
        - 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장
            - 2s    a초기에는 첫 정점의 거리는 0, 나머지는 무한대로 저장함 (inf로 표현)
            - 우선순위 큐에 (첫 정점, 거리 0)만 먼저 넣음 
        거리 저장 배열                  우선순위 큐
        A  B   C   D   E   F                A
        0 inf inf inf inf inf 

    2단계. 우선순위 큐에서 추출한 (A, 0) [노드, 첫 노드와의 거리]를 기반으로 인접한 노드와의 거리 계산
        - 우선순위 큐에서 노드를 꺼냄
            - 처음에는 첫 정점만 저장되어 있으므로, 첫 정점이 꺼내짐
            - 첫 정점에 인접한 노드들 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교
            - 배열에 저장되어 있는 거리보다 첫 정점에서 해당 노드로 가는 거리가 더 짧은 경우, 배열에 해당 노드의 거리를 업데이트한다.
            - 배열에 해당 노드의 거리가 업데이트 된 경우, 우선순위 큐에 넣는다
                - 결과적으로 너비 우선 탐색 방식과 유사하게, 첫 정점에 인접한 노드들을 순차적으로 방문하게 됨
                - 만약 배열에 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리(루트)를 가진(노드, 거리)의 경우에는 해당 노드와 인접한 노드간의 거리 계산을 하지 않음

큐에서 추출            거리 저장 배열                  우선순위 큐 (Min Heap)
    A, 0            A  B   C   D   E   F                 B
                    0  8  inf inf inf inf                8

큐에서 추출            거리 저장 배열                  우선순위 큐
    A, 0            A  B   C   D   E   F                 C B 
                    0  8   1  inf inf inf                1 8

큐에서 추출            거리 저장 배열                  우선순위 큐
    A, 0            A  B   C   D   E   F                 C D B 
                    0  8   1   2  inf inf                1 2 8

    3단계. 우선순위 큐에서 (C, 1) [노드, 첫 노드와의 거리]를 기반으로 인접한 노드와의 거리 계산
        - 우선순위 큐가 MinHeap(최소 힙) 방식이므로, 위 표에서 넣어진 (C, 1), (D, 2), (B, 8) 중 (C, 1)이 먼저 추출됨(pop)
        - 위 표에서 보듯이 1단계까지의 A - B 최단거리는 8인 상황
            - A - c까지의 거리는 1, C 에 인접한 B, D에서 C - B는 5, 즉 A - C - B는 1 + 5 = 6이므로, A - B 최단거리 8 보다 더 작은 거리를 발견, 이를 배열에 업데이트
                * 배열에 업데이트했으므로 (B, 6(즉 A에서 B까지의 현재까지 발견한 최단 거리)) 값이 우선순위 큐에 넣어짐
            - C - D의 거리는 2, 즉 A - C - D 는 1 + 2 = 3이므로, A - D의 현재 최단 거리인 2보다 긴 거리, 그래서 D의 거리는 업데이트되지 않음

큐에서 추출            거리 저장 배열                  우선순위 큐
    C, 1            A  B  C  D   E   F                 D B B 
                    0  6  1  2  inf inf                2 6 8

    4단계. 우선순위 큐에서 (D, 2) [노드, 첫 노드와의 거리]를 기반으로 인접한 노드와의 거리 계산

큐에서 추출            거리 저장 배열                  우선순위 큐
    D, 2            A  B  C  D   E   F                 E B B 
                    0  6  1  2   5  inf                5 6 8

큐에서 추출            거리 저장 배열                  우선순위 큐
    D, 2            A  B  C  D  E  F                   E B F B 
                    0  6  1  2  5  7                   5 6 7 8

    5단계. 우선순위 큐에서 (E, 5) [노드, 첫 노드와의 거리]를 기반으로 인접한 노드와의 거리 계산

큐에서 추출            거리 저장 배열                  우선순위 큐
    E, 5            A  B  C  D  E  F                    B F F B 
                    0  6  1  2  5  6                    6 6 7 8
    
    6단계. 우선순위 큐에서 (B, 6) [노드, 첫 노드와의 거리]를 기반으로 인접한 노드와의 거리 계산

큐에서 추출            거리 저장 배열                  우선순위 큐
    B, 6            A  B  C  D  E  F                    F F B 
                    0  6  1  2  5  6                    6 7 8

큐에서 추출            거리 저장 배열                  우선순위 큐
    F, 6            A  B  C  D  E  F                    F B 
                    0  6  1  2  5  6                    7 8
                    
큐에서 추출            거리 저장 배열                  우선순위 큐
    F, 7            A  B  C  D  E  F                     B 
                    0  6  1  2  5  6                     8

큐에서 추출            거리 저장 배열                  우선순위 큐
    B, 8            A  B  C  D  E  F                      
                    0  6  1  2  5  6                     

우선순위 큐의 장점
    - 지금까지 발견된 가장 짧은 거리의 노드엥 대해서 먼저 계산
    - 더 긴 거리로 계산된 루트에 대해서는 계산을 스킵할 수 있음

4. 다익스트라 알고리즘 파이썬 구현(우선순위 큐 활용)
"""
import heapq

queue = []

heapq.heappush(queue, [2, 'A'])
heapq.heappush(queue, [5, 'B'])
heapq.heappush(queue, [1, 'C'])
heapq.heappush(queue, [7, 'D'])
print(queue) # [[1, 'C'], [5, 'B'], [2, 'A'], [7, 'D']]
for index in range(len(queue)):
    print(heapq.heappop(queue))
    # [1, 'C']
    # [2, 'A']
    # [5, 'B']
    # [7, 'D']

mygraph = {
    'A' : {'B': 8, 'C' : 1, 'D' : 2},
    'B' : {},
    'C' : {'B' : 5,'D' : 2},
    'D' : {'E' : 3, 'F' : 5},
    'E' : {'F' : 1},
    'F' : {'A' : 5}
}


def dijkstra (graph, start):
    # 초기화    
    distances = {node : float('inf') for node in graph}
    distances[start] = 0
    queue = []
    heapq.heappush(queue, [distances[start], start]) 

    while queue:
        current_distance, current_node = heapq.heappop(queue)

        if distances[current_node] < current_distance: 
            continue

        for adjacent, weight in graph[current_node].items():
            distance = current_distance + weight

            if distance < distances[adjacent]:
                distances[adjacent] = distance
                heapq.heappush(queue, [distance, adjacent])
    return distances

print(dijkstra(mygraph, 'A')) # {'A': 0, 'B': 6, 'C': 1, 'D': 2, 'E': 5, 'F': 6}


"""
시간 복잡도 : O (ElogE)
과정 1 : 각 노드마다 인접한 간선들을 모두 검사하는 과정 >> O(E) / E = 간선
과정 2 : 우선순위 큐에 노드/거리 정보를 넣고 삭제(pop)하는 과정 >> 각 간선마다 최대 한 번 일어날수 있으므로 최대 O(E) + 노드/거리 정보에 대해 우선순위 큐를 유지하기 위한 작업 : O(logE)  
>>>>> 과정 1 + 과정 2 = O(ElogE)
"""